!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Bullet={})}(this,(function(t){"use strict";class e{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}cross(t,e){const s=t.x,i=t.y,o=t.z,n=this.x,r=this.y,a=this.z;return e.x=r*o-a*i,e.y=a*s-n*o,e.z=n*i-r*s,e}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}setZero(){this.x=this.y=this.z=0}normalize(){const t=this.x,e=this.y,s=this.z,i=Math.sqrt(t*t+e*e+s*s);if(i>0){const t=1/i;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return i}length(){const t=this.x,e=this.y,s=this.z;return Math.sqrt(t*t+e*e+s*s)}distanceTo(t){const e=this.x,s=this.y,i=this.z,o=t.x,n=t.y,r=t.z;return Math.sqrt((o-e)*(o-e)+(n-s)*(n-s)+(r-i)*(r-i))}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,s){const i=this.x,o=this.y,n=this.z;s.x=i+(t.x-i)*e,s.y=o+(t.y-o)*e,s.z=n+(t.z-n)*e}clone(){return new e(this.x,this.y,this.z)}}e.ZERO=new e(0,0,0),e.UNIT_X=new e(1,0,0),e.UNIT_Y=new e(0,1,0),e.UNIT_Z=new e(0,0,1);class s{constructor(t=0,e=0,s=0,i=1){this.x=t,this.y=e,this.z=s,this.w=i}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e="YZX"){let s,i,o;const n=this.x,r=this.y,a=this.z,h=this.w;switch(e){case"YZX":const t=n*r+a*h;if(t>.499&&(s=2*Math.atan2(n,h),i=Math.PI/2,o=0),t<-.499&&(s=-2*Math.atan2(n,h),i=-Math.PI/2,o=0),void 0===s){const e=n*n,c=r*r,l=a*a;s=Math.atan2(2*r*h-2*n*a,1-2*c-2*l),i=Math.asin(2*t),o=Math.atan2(2*n*h-2*r*a,1-2*e-2*l)}break;default:throw new Error(`Euler order ${e} not supported yet.`)}t.y=s,t.z=i,t.x=o}setFromEuler(t,e,s,i="XYZ"){const o=Math.cos(t/2),n=Math.cos(e/2),r=Math.cos(s/2),a=Math.sin(t/2),h=Math.sin(e/2),c=Math.sin(s/2);return"XYZ"===i?(this.x=a*n*r+o*h*c,this.y=o*h*r-a*n*c,this.z=o*n*c+a*h*r,this.w=o*n*r-a*h*c):"YXZ"===i?(this.x=a*n*r+o*h*c,this.y=o*h*r-a*n*c,this.z=o*n*c-a*h*r,this.w=o*n*r+a*h*c):"ZXY"===i?(this.x=a*n*r-o*h*c,this.y=o*h*r+a*n*c,this.z=o*n*c+a*h*r,this.w=o*n*r-a*h*c):"ZYX"===i?(this.x=a*n*r-o*h*c,this.y=o*h*r+a*n*c,this.z=o*n*c-a*h*r,this.w=o*n*r+a*h*c):"YZX"===i?(this.x=a*n*r+o*h*c,this.y=o*h*r+a*n*c,this.z=o*n*c-a*h*r,this.w=o*n*r-a*h*c):"XZY"===i&&(this.x=a*n*r-o*h*c,this.y=o*h*r-a*n*c,this.z=o*n*c+a*h*r,this.w=o*n*r+a*h*c),this}clone(){return new s(this.x,this.y,this.z,this.w)}}const i="static",o="dynamic",n="kinematic";class r{constructor(){this._shape=null,this.type=""}setMargin(t){this._shape.setMargin(t)}static fromMesh(){}static CreateShape(t,e){let s=null,i=t&&t.isMesh?t.geometry.parameters:{};if(void 0!==e)switch(e){case"box":s=new a(i.width,i.height,i.depth);break;case"sphere":s=new h(i.radius);break;case"capsule":s=new c;break;case"cylinder":s=new l(Math.max(i.radiusTop,i.radiusBottom),i.height);break;case"cone":s=new m(i.radius,i.height);break;case"convex":s=new _(t);break;case"mesh":s=new u(t);break;case"gmesh":s=new d(t);break;case"compound":s=new y}else switch(t.geometry.type){case"BoxGeometry":s=new a(i.width,i.height,i.depth);break;case"SphereGeometry":s=new h(i.radius);break;case"CylinderGeometry":s=new l(Math.max(i.radiusTop,i.radiusBottom),i.height);break;case"ConeGeometry":s=new m(i.radius,i.height)}return s}}class a extends r{constructor(t=1,e=1,s=1){super(),this._shape=new Ammo.btBoxShape(new Ammo.btVector3(t/2,e/2,s/2))}}class h extends r{constructor(t=.5){super(),this._shape=new Ammo.btSphereShape(t)}}class c extends r{constructor(t=.5,e=2){super(),e=Math.max(e-2*t,0),this._shape=new Ammo.btCapsuleShape(t,e)}}class l extends r{constructor(t=.5,e=1){super(),this._shape=new Ammo.btCylinderShape(new Ammo.btVector3(t,e/2,t))}}class m extends r{constructor(t=1,e=1){super(),this._shape=new Ammo.btConeShape(t,e)}}class y extends r{constructor(){super(),this._shape=new Ammo.btCompoundShape}addShape(t,i=new e(0,0,0),o=new s(0,0,0,1)){let n=new Ammo.btTransform;n.setIdentity(),n.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),n.setRotation(new Ammo.btQuaternion(o.x,o.y,o.z,o.w)),this._shape.addChildShape(n,t._shape)}}class d extends r{constructor(t){let e,s;super();let i=0;if("Mesh"==t.type){let o=b(t);console.log(o),e=o.faces,s=o.vertices,i=s.length}else console.error("cannot make mesh shape for non-Mesh object");0==i&&console.error("no vertices to define mesh shape with");let o=new Ammo.btTriangleMesh(!0,!0);for(let t=0,i=e.length;t<i;t++){let i=e[t].a,n=e[t].b,r=e[t].c;o.addTriangle(new Ammo.btVector3(s[i].x,s[i].y,s[i].z),new Ammo.btVector3(s[n].x,s[n].y,s[n].z),new Ammo.btVector3(s[r].x,s[r].y,s[r].z),!1)}this._shape=new Ammo.btGImpactMeshShape(o)}}class _ extends r{constructor(t){if(super(),t.isMesh){this._shape=new Ammo.btConvexHullShape;let e=t.scale,s=b(t).vertices,i=new Ammo.btVector3(0,0,0);for(let t=0;t<s.length;t++){let o=e.x*s[t].x,n=e.y*s[t].y,r=e.z*s[t].z;i.setValue(o,n,r),this._shape.addPoint(i,!0)}}else console.error("cannot make Convex Hull collision shape for non-Mesh object")}}class u extends r{constructor(t){let e,s;super();let i=0;if(t.isMesh){let o=b(t);e=o.faces,s=o.vertices,i=s.length}else console.error("cannot make mesh shape for non-Mesh object");0==i&&console.error("no vertices to define mesh shape with"),this._shape=new Ammo.btCompoundShape;let o=new Ammo.btTriangleMesh(!0,!0);for(let t=0,i=e.length;t<i;t++){let i=e[t].a,n=e[t].b,r=e[t].c;o.addTriangle(new Ammo.btVector3(s[i].x,s[i].y,s[i].z),new Ammo.btVector3(s[n].x,s[n].y,s[n].z),new Ammo.btVector3(s[r].x,s[r].y,s[r].z),!1)}let n=new Ammo.btBvhTriangleMeshShape(o,!0,!0),r=new Ammo.btTransform;r.setIdentity(),r.setOrigin(new Ammo.btVector3(0,0,0)),r.setRotation(new Ammo.btQuaternion(0,0,0,1)),this._shape.addChildShape(r,n)}}function b(t){const e=null!==t.geometry.index?t.geometry.index:void 0,s=t.geometry.attributes,i=t.scale;if(void 0===s.position)return void console.error("getMeshData(): Position attribute required for conversion.");const o=s.position;let n=[],r=[];for(let t=0;t<o.count;t++)n.push({x:i.x*o.getX(t),y:i.y*o.getY(t),z:i.z*o.getZ(t)});if(void 0!==e)for(let t=0;t<e.count;t+=3)r.push({a:e.getX(t),b:e.getX(t+1),c:e.getX(t+2)});else for(let t=0;t<o.count;t+=3)r.push({a:t,b:t+1,c:t+2});return{vertices:n,faces:r}}class p{constructor(){this._constraint=null,this._bodyA=null,this._bodyB=null,this._breakForce=34e37,this._enableCollision=!0}set bodyA(t){this._bodyA=t}get bodyA(){return this._bodyA}set bodyB(t){this._bodyB=t}get bodyB(){return this._bodyB}set breakForce(t){this._constraint&&this._breakForce!==t&&(this._constraint.setBreakingImpulseThreshold(t),this._breakForce=t)}get breakForce(){return this._breakForce}set enableCollision(t){this._destroyConstraint(),this._enableCollision=t,this._createConstraint()}get enableCollision(){return this._enableCollision}}t.Box=a,t.Capsule=c,t.Compound=y,t.Cone=m,t.ConvexHull=_,t.Cylinder=l,t.HingeJoint=class extends p{constructor(t,e,s,i,o,n){super();let r=t._body,a=new Ammo.btVector3(e.x,e.y,e.z),h=new Ammo.btVector3(s.x,s.y,s.z);if(i&&o&&n){let t=i._body,e=new Ammo.btVector3(o.x,o.y,o.z),s=new Ammo.btVector3(n.x,n.y,n.z);this._constraint=new Ammo.btHingeConstraint(r,t,a,e,h,s)}else this._constraint=new Ammo.btHingeConstraint(r,a,h)}},t.Joint=p,t.Mesh=u,t.PointJoint=class extends p{constructor(t,e,s,i){super();let o=t._body,n=new Ammo.btVector3(e.x,e.y,e.z);if(s&&i){let t=s._body,e=new Ammo.btVector3(i.x,i.y,i.z);this._constraint=new Ammo.btPoint2PointConstraint(o,t,n,e)}else this._constraint=new Ammo.btPoint2PointConstraint(o,n)}},t.Quaternion=s,t.RigidBody=class{constructor(t,n={}){this.entity=t,t.userData.body=this,this._body=null,this._mass=void 0!==n.mass?n.mass:1,this._type=i,this._friction=.5,this._restitution=0;let r=void 0!==n.shape?n.shape:null;this._shape=r._shape,this._position=void 0!==n.position?n.position:new e,this._quaternion=void 0!==n.quaternion?n.quaternion:new s,this._angularDamping=0,this._angularFactor=new e(1,1,1),this._angularVelocity=new e,this._linearDamping=0,this._linearFactor=new e(1,1,1),this._linearVelocity=new e,this._type=o}get type(){return this._type}set type(t){if(this._type!==t)switch(this._type=t,t){case o:this._group=1;break;case n:this._group=4;break;case i:default:this._group=2}}get mass(){return this._mass}set mass(t){if(this._mass!==t&&(this._mass=t,this._body&&this._type===o)){this.enabled&&this.entity.enabled&&this.disableSimulation();let e=new Ammo.btVector3(0,0,0);t&&this._body.getCollisionShape().calculateLocalInertia(t,e),this._body.setMassProps(t,e),this._body.updateInertiaTensor()}}get position(){return this._position}set position(t){if(this._position.copy(t),this._body){rot=this._body.getWorldTransform().getRotation();let e=new Ammo.btTransform;if(e.setIdentity(),e.setOrigin(new Ammo.btVector3(t.x,t.y,t.z)),e.setRotation(rot),this._body.setWorldTransform(e),0==this.mass||this._type===n){const t=this._body.getMotionState();t&&t.setWorldTransform(e)}}}get quaternion(){return this._quaternion}get angularDamping(){return this._angularDamping}set angularDamping(t){this._angularDamping!==t&&(this._angularDamping=t,this._body&&this._body.setDamping(this._linearDamping,t))}get angularFactor(){return this._angularFactor}set angularFactor(t){if(!this._angularFactor.equals(t)&&(this._angularFactor.copy(t),this._body&&this._type===o)){let e=new Ammo.btVector3(t.x,t.y,t.z);this._body.setAngularFactor(e)}}get angularVelocity(){if(this._body&&this._type===o){const t=this._body.getAngularVelocity();this._angularVelocity.set(t.x(),t.y(),t.z())}return this._angularVelocity}set angularVelocity(t){if(this._body&&this._type===o){this._body.activate();let e=new Ammo.btVector3(t.x,t.y,t.z);this._body.setAngularVelocity(e),this._angularVelocity.copy(t)}}get linearDamping(){return this._linearDamping}set linearDamping(t){this._linearDamping!==t&&(this._linearDamping=t,this._body&&this._body.setDamping(t,this._angularDamping))}get linearFactor(){return this._linearFactor}set linearFactor(t){if(!this._linearFactor.equals(t)&&(this._linearFactor.copy(t),this._body&&this._type===o)){let e=new Ammo.btVector3(t.x,t.y,t.z);this._body.setLinearFactor(e)}}get linearVelocity(){if(this._body&&this._type===o){const t=this._body.getLinearVelocity();this._linearVelocity.set(t.x(),t.y(),t.z())}return this._linearVelocity}set linearVelocity(t){if(this._body&&this._type===o){this._body.activate();let e=new Ammo.btVector3(t.x,t.y,t.z);this._body.setLinearVelocity(e),this._linearVelocity.copy(t)}}get friction(){return this._friction}set friction(t){this._friction!==t&&(this._friction=t,this._body&&this._body.setFriction(t))}get restitution(){return this._restitution}set restitution(t){this._restitution!==t&&(this._restitution=t,this._body&&this._body.setRestitution(t))}setKinematic(t){let e=this._body;t?e.setCollisionFlags(e.getCollisionFlags()|CF_KINEMATIC_OBJECT):e.setCollisionFlags(e.getCollisionFlags()&~CF_KINEMATIC_OBJECT)}addToWorld(t){return t.addBody(this),this}isActive(){return!!this._body&&this._body.isActive()}activate(){this._body&&this._body.activate()}_getEntityTransform(){let t=new Ammo.btTransform;t.setIdentity();const e=this.entity,s=e.position,i=e.rotation;return t.setOrigin(new Ammo.btVector3(s.x,s.y,s.z)),t.setRotation(new Ammo.btQuaternion(i.x,i.y,i.z,i.w)),t}_getTransform(){let t=new Ammo.btTransform;t.setIdentity();const e=this.position,s=this.quaternion;return t.setOrigin(new Ammo.btVector3(e.x,e.y,e.z)),t.setRotation(new Ammo.btQuaternion(s.x,s.y,s.z,s.w)),t}_setActivationState(t){t?this._body.forceActivationState(ACTIVE_TAG):this._body.setActivationState(DISABLE_DEACTIVATION)}setActivationState(t){this._body.setActivationState(t)}createBody(){const t=this.entity;let e=this._shape;if(e){const s=this._type===o?this._mass:0;let i=this._getTransform();const r=new Ammo.btVector3(0,0,0);0!==s&&e.calculateLocalInertia(s,r);const a=new Ammo.btDefaultMotionState(i),h=new Ammo.btRigidBodyConstructionInfo(s,a,e,r),c=new Ammo.btRigidBody(h);Ammo.destroy(h),Ammo.destroy(r),c.setRestitution(this._restitution),c.setFriction(this._friction),c.setRollingFriction(this._rollingFriction),c.setDamping(this._linearDamping,this._angularDamping);let l=new Ammo.btVector3;if(this._type===o){const t=this._linearFactor;l.setValue(t.x,t.y,t.z),c.setLinearFactor(l);const e=this._angularFactor;l.setValue(e.x,e.y,e.z),c.setAngularFactor(l)}else this._type===n&&(c.setCollisionFlags(2|c.getCollisionFlags()),c.setActivationState(4));c.entity=t,this._body=c,this.enabled&&t.enabled}}update(t){let e=new Ammo.btTransform;const s=this._body.getMotionState();if(s){s.getWorldTransform(e);const i=e.getOrigin(),o=e.getRotation();t.position.set(i.x(),i.y(),i.z()),t.quaternion.set(o.x(),o.y(),o.z(),o.w())}}},t.Shape=r,t.SixDofSpringJoint=class extends p{constructor(t,e,s,i,o,n){super();let r=t._body;if(new Ammo.btVector3(e.x,e.y,e.z),new Ammo.btVector3(s.x,s.y,s.z),i&&o&&n){let t=i._body;new Ammo.btVector3(o.x,o.y,o.z),new Ammo.btVector3(n.x,n.y,n.z),this._constraint=new Ammo.btGeneric6DofSpringConstraint(r,t,frameA,frameB,!this._enableCollision),Ammo.destroy(frameB)}else this._constraint=new Ammo.btGeneric6DofSpringConstraint(r,frameA,!this._enableCollision);const a=["X","Y","Z","X","Y","Z"];for(let t=0;t<6;t++){const e=t<3?"_linear":"_angular";this._constraint.enableSpring(t,this[e+"Spring"+a[t]]),this._constraint.setDamping(t,this[e+"Damping"+a[t]]),this._constraint.setEquilibriumPoint(t,this[e+"Equilibrium"+a[t]]),this._constraint.setStiffness(t,this[e+"Stiffness"+a[t]])}}},t.Sphere=h,t.Vec3=e,t.World=class{constructor(t={}){const s=new Ammo.btDefaultCollisionConfiguration,i=new Ammo.btCollisionDispatcher(s),o=new Ammo.btDbvtBroadphase,n=new Ammo.btSequentialImpulseConstraintSolver;this._dynamicsWorld=new Ammo.btDiscreteDynamicsWorld(i,o,n,s),this._gravity=new e,this.gravity=void 0!==t.gravity?t.gravity:new e(0,-9.82,0),this.bodies=[]}get gravity(){return this._gravity}set gravity(t){this._gravity.copy(t),this._dynamicsWorld.setGravity(new Ammo.btVector3(t.x,t.y,t.z))}addBody(t){t.createBody(),this.bodies.push(t),this._dynamicsWorld.addRigidBody(t._body)}removeBody(t){let e=this.bodies.indexOf(t);this.bodies.splice(e,1),this._dynamicsWorld.removeRigidBody(t._body)}addJoint(t,e=!1){this._dynamicsWorld.addConstraint(t._constraint,e)}removeJoint(t){this._dynamicsWorld.removeConstraint(t._constraint)}addAction(t){this._dynamicsWorld.addAction(t)}removeAction(t){this._dynamicsWorld.removeAction(t)}step(t,e=1,s=1/60){this._dynamicsWorld.stepSimulation(t,e,s);for(let t=0,e=this.bodies.length;t<e;t++){const e=this.bodies[t],s=e.entity;e.update(s)}}},Object.defineProperty(t,"__esModule",{value:!0})}));
